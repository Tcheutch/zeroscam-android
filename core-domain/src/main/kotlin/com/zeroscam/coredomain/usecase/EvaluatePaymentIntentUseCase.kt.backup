package com.zeroscam.coredomain.usecase

import com.zeroscam.coredomain.enums.RiskLevel
import com.zeroscam.coredomain.enums.SubscriptionPlan
import com.zeroscam.coredomain.model.DetectionResult
import com.zeroscam.coredomain.model.PaymentIntent
import com.zeroscam.coredomain.ports.DetectionLogRepository
import com.zeroscam.coredomain.ports.PaymentRiskEngine
import com.zeroscam.coredomain.ports.ThreatIntelRepository

/**
 * Use case : évaluation du risque d'une intention de paiement avant exécution.
 *
 * Pipeline (aligné Vigilis / Vigilis-Research) :
 *  1. Score de risque brut via [PaymentRiskEngine] :
 *     - modèle ML
 *     - règles métiers (montant, device posture, hash, etc.)
 *  2. Ajustement via threat intel :
 *     - destinations connues scam, IOC externes, etc.
 *  3. Escalades déterministes :
 *     - destination connue scam
 *     - signaux techniques forts (hash-jacking, device compromis, jailbreak)
 *  4. Ajustement par politique :
 *     - Afrique (XAF/XOF & co) vs reste du monde,
 *     - canal (MoMo, USSD, wallet…) vs card/bank,
 *     - plan d'abonnement (FREE vs payant) si disponible.
 *  5. Journalisation structurée pour traçabilité & future feedback loop.
 */
class EvaluatePaymentIntentUseCase(
    private val paymentRiskEngine: PaymentRiskEngine,
    private val threatIntelRepository: ThreatIntelRepository,
    private val detectionLogRepository: DetectionLogRepository,
) {
    /**
     * Version simple : pas de plan explicite.
     *
     * Par défaut, on assume un plan "low touch" (FREE / basic) côté politique.
     */
    operator fun invoke(paymentIntent: PaymentIntent): DetectionResult = evaluate(
        paymentIntent = paymentIntent,
        userPlan = null,
    )

    /**
     * Version enrichie : permet d'appliquer une politique différente
     * selon le plan (FREE, PRO, ENTERPRISE, etc.).
     */
    fun evaluate(
        paymentIntent: PaymentIntent,
        userPlan: SubscriptionPlan?,
    ): DetectionResult {
        // 1) Score brut (ML + règles + signaux device/hash)
        val baseResult = paymentRiskEngine.analyze(paymentIntent)

        // 2) Ajustement par la threat intel
        val intelAdjusted = threatIntelRepository.adjustPaymentResult(
            paymentIntent = paymentIntent,
            initialResult = baseResult,
        )

        // 3) Escalades déterministes
        val afterKnownScamEscalation = escalateForKnownScamDestination(intelAdjusted)
        val afterTechnicalSignalsEscalation = escalateForTechnicalSignals(
            afterKnownScamEscalation,
        )

        // 4) Ajustement par la politique Afrique / canal / plan
        val policyAdjusted = adjustForPlanRegionAndChannel(
            currentResult = afterTechnicalSignalsEscalation,
            paymentIntent = paymentIntent,
            userPlan = userPlan,
        )

        // 5) Journalisation
        detectionLogRepository.logPaymentDetection(
            paymentIntent = paymentIntent,
            result = policyAdjusted,
        )

        return policyAdjusted
    }

    /**
     * Escalade si la threat-intel a déjà signalé la destination comme scam.
     */
    private fun escalateForKnownScamDestination(
        currentResult: DetectionResult,
    ): DetectionResult {
        val hasKnownScamReason = currentResult.reasons.any { reason ->
            reason == REASON_DESTINATION_KNOWN_SCAM
        }

        if (!hasKnownScamReason) {
            return currentResult
        }

        val targetRisk = when (currentResult.riskLevel) {
            RiskLevel.LOW -> RiskLevel.HIGH
            RiskLevel.MEDIUM -> RiskLevel.HIGH
            RiskLevel.HIGH -> RiskLevel.HIGH
            RiskLevel.CRITICAL -> RiskLevel.CRITICAL
        }

        val targetConfidence = if (currentResult.riskLevel >= RiskLevel.HIGH) {
            currentResult.confidenceScore
        } else {
            maxOf(currentResult.confidenceScore, 0.95)
        }

        return currentResult.copy(
            riskLevel = targetRisk,
            confidenceScore = targetConfidence,
            reasons = currentResult.reasons + REASON_ESCALATION_DESTINATION_SCAM,
        )
    }

    /**
     * Escalade basée sur les signaux techniques forts :
     *  - hash-jacking détecté (mismatch de payload hash),
     *  - device compromis / rooté / jailbreak détecté,
     *  - combinaison de plusieurs signaux en même temps.
     */
    private fun escalateForTechnicalSignals(
        currentResult: DetectionResult,
    ): DetectionResult {
        val reasons = currentResult.reasons.toSet()

        val hasHashJacking = reasons.contains(REASON_HASH_JACKING_SUSPECTED)
        val hasDeviceCompromised = reasons.contains(REASON_DEVICE_COMPROMISED)
        val hasJailbreak = reasons.contains(REASON_DEVICE_JAILBROKEN)

        val technicalSignalsCount = listOf(
            hasHashJacking,
            hasDeviceCompromised,
            hasJailbreak,
        ).count { it }

        if (technicalSignalsCount == 0) {
            return currentResult
        }

        var escalatedRisk = bumpRisk(currentResult.riskLevel)
        var escalatedConfidence = maxOf(currentResult.confidenceScore, 0.85)

        if (technicalSignalsCount >= 2) {
            escalatedRisk = when (currentResult.riskLevel) {
                RiskLevel.LOW,
                RiskLevel.MEDIUM -> RiskLevel.HIGH
                RiskLevel.HIGH -> RiskLevel.CRITICAL
                RiskLevel.CRITICAL -> RiskLevel.CRITICAL
            }
            escalatedConfidence = maxOf(escalatedConfidence, 0.95)
        }

        val extraReasons = mutableListOf<String>()
        if (hasHashJacking) {
            extraReasons += REASON_ESCALATION_HASH_JACKING
        }
        if (hasDeviceCompromised) {
            extraReasons += REASON_ESCALATION_DEVICE_COMPROMISED
        }
        if (hasJailbreak) {
            extraReasons += REASON_ESCALATION_JAILBROKEN
        }

        return currentResult.copy(
            riskLevel = escalatedRisk,
            confidenceScore = escalatedConfidence,
            reasons = currentResult.reasons + extraReasons,
        )
    }

    /**
     * Ajustement par la politique ZeroScam :
     *  - Afrique (CEMAC, UEMOA, Afrique hors zone) vs reste du monde
     *  - canaux MoMo / USSD / wallet considérés plus à risque
     *  - plans payants : politique plus stricte (moins de faux négatifs)
     */
    private fun adjustForPlanRegionAndChannel(
        currentResult: DetectionResult,
        paymentIntent: PaymentIntent,
        userPlan: SubscriptionPlan?,
    ): DetectionResult {
        val context = resolveRiskContext(
            paymentIntent = paymentIntent,
            userPlan = userPlan,
        )

        if (!context.isAfricanUser) {
            // Politique renforcée ciblée sur l'Afrique pour l'instant.
            return currentResult
        }

        val isHighRiskChannel = context.channelRiskBucket == ChannelRiskBucket.HIGH
        if (!isHighRiskChannel) {
            return currentResult
        }

        var risk = currentResult.riskLevel
        var confidence = currentResult.confidenceScore
        val extraReasons = mutableListOf<String>()

        if (!context.isHighTouchPlan) {
            // FREE / trial / low-touch : on sécurise sans tout bloquer
            if (risk == RiskLevel.LOW) {
                risk = RiskLevel.MEDIUM
                confidence = maxOf(confidence, 0.80)
                extraReasons += REASON_ESCALATION_AFRICA_MOBILE_FREE_PLAN
            }
        } else {
            // Plans payants (PRO, PREMIUM, ENTERPRISE, etc.) :
            // on préfère rater un scam de moins → politique agressive.
            when (risk) {
                RiskLevel.LOW -> {
                    risk = RiskLevel.HIGH
                    confidence = maxOf(confidence, 0.90)
                }
                RiskLevel.MEDIUM -> {
                    risk = RiskLevel.HIGH
                    confidence = maxOf(confidence, 0.90)
                }
                RiskLevel.HIGH -> {
                    if (confidence >= 0.90) {
                        risk = RiskLevel.CRITICAL
                    }
                }
                RiskLevel.CRITICAL -> {
                    // déjà au maximum
                }
            }
            extraReasons += REASON_ESCALATION_AFRICA_MOBILE_HIGH_TOUCH_PLAN
        }

        if (extraReasons.isEmpty()) {
            return currentResult
        }

        return currentResult.copy(
            riskLevel = risk,
            confidenceScore = confidence,
            reasons = currentResult.reasons + extraReasons,
        )
    }

    private fun resolveRiskContext(
        paymentIntent: PaymentIntent,
        userPlan: SubscriptionPlan?,
    ): PaymentRiskContext {
        val currency = paymentIntent.currency.uppercase()

        val region = when (currency) {
            // CEMAC
            "XAF" -> RegionBucket.CEMAC
            // UEMOA
            "XOF" -> RegionBucket.UEMOA
            // Afrique hors XAF/XOF
            "NGN",
            "GHS",
            "KES",
            "TZS",
            "UGX",
            "RWF",
            "ZMW",
            "ZAR",
            "MAD",
            "EGP" -> RegionBucket.AFRICA_OTHER
            // Devises typiquement non africaines
            "USD",
            "EUR",
            "GBP" -> RegionBucket.NON_AFRICA
            else -> RegionBucket.UNKNOWN
        }

        val isAfricanUser = when (region) {
            RegionBucket.CEMAC,
            RegionBucket.UEMOA,
            RegionBucket.AFRICA_OTHER -> true
            RegionBucket.NON_AFRICA,
            RegionBucket.UNKNOWN -> false
        }

        val channelRiskBucket = classifyChannelRisk(paymentIntent)
        val isHighTouchPlan = isHighTouchPlan(userPlan)

        return PaymentRiskContext(
            isAfricanUser = isAfricanUser,
            region = region,
            channelRiskBucket = channelRiskBucket,
            isHighTouchPlan = isHighTouchPlan,
        )
    }

    private fun classifyChannelRisk(
        paymentIntent: PaymentIntent,
    ): ChannelRiskBucket {
        val channelName = paymentIntent.channel.toString().lowercase()

        return when {
            channelName.contains("mobile") ||
                channelName.contains("momo") ||
                channelName.contains("wallet") ||
                channelName.contains("ussd") ||
                channelName.contains("crypto") -> ChannelRiskBucket.HIGH
            channelName.contains("card") ||
                channelName.contains("debit") ||
                channelName.contains("credit") ||
                channelName.contains("transfer") ||
                channelName.contains("bank") -> ChannelRiskBucket.MEDIUM
            else -> ChannelRiskBucket.LOW
        }
    }

    /**
     * Heuristique "high touch" sans dépendre d'une propriété `name` :
     *
     *  - FREE / TRIAL -> low-touch
     *  - tout le reste -> high-touch (plans payants).
     *
     *  On passe par `toString()` pour rester compatible :
     *   - enum
     *   - data class
     *   - sealed class
     */
    private fun isHighTouchPlan(
        plan: SubscriptionPlan?,
    ): Boolean {
        val planString = plan
            ?.toString()
            ?.lowercase()
            ?: return false

        if (planString.contains("free") || planString.contains("trial")) {
            return false
        }

        return true
    }

    private fun bumpRisk(
        riskLevel: RiskLevel,
    ): RiskLevel = when (riskLevel) {
        RiskLevel.LOW -> RiskLevel.MEDIUM
        RiskLevel.MEDIUM -> RiskLevel.HIGH
        RiskLevel.HIGH -> RiskLevel.CRITICAL
        RiskLevel.CRITICAL -> RiskLevel.CRITICAL
    }

    private data class PaymentRiskContext(
        val isAfricanUser: Boolean,
        val region: RegionBucket,
        val channelRiskBucket: ChannelRiskBucket,
        val isHighTouchPlan: Boolean,
    )

    private enum class RegionBucket {
        CEMAC,
        UEMOA,
        AFRICA_OTHER,
        NON_AFRICA,
        UNKNOWN,
    }

    private enum class ChannelRiskBucket {
        HIGH,
        MEDIUM,
        LOW,
    }

    companion object {
        // Reasons produits côté ThreatIntel / moteur / device-security
        private const val REASON_DESTINATION_KNOWN_SCAM = "destination_known_scam"
        private const val REASON_HASH_JACKING_SUSPECTED = "hash_jacking_suspected"
        private const val REASON_DEVICE_COMPROMISED = "device_compromised"
        private const val REASON_DEVICE_JAILBROKEN = "device_jailbroken"

        // Reasons ajoutés par ce use-case lors des escalades déterministes
        private const val REASON_ESCALATION_DESTINATION_SCAM = "escalation_destination_known_scam"
        private const val REASON_ESCALATION_HASH_JACKING = "escalation_hash_jacking_signal"
        private const val REASON_ESCALATION_DEVICE_COMPROMISED = "escalation_device_compromised_signal"
        private const val REASON_ESCALATION_JAILBROKEN = "escalation_jailbroken_signal"

        // Reasons ajoutés par la politique Afrique / canal / plan
        private const val REASON_ESCALATION_AFRICA_MOBILE_FREE_PLAN = "escalation_africa_mobile_free_plan"
        private const val REASON_ESCALATION_AFRICA_MOBILE_HIGH_TOUCH_PLAN = "escalation_africa_mobile_high_touch_plan"
    }
}