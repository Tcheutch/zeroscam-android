package com.zeroscam.coredomain.usecase

import com.zeroscam.coredomain.enums.RiskLevel
import com.zeroscam.coredomain.model.DetectionResult
import com.zeroscam.coredomain.model.Message
import com.zeroscam.coredomain.ports.DetectionLogRepository
import com.zeroscam.coredomain.ports.MessageScamDetector
import com.zeroscam.coredomain.ports.ThreatIntelRepository

/**
 * Use case : analyse d'un message entrant (SMS, WhatsApp, email, push, etc.).
 *
 * Pipeline (aligné Vigilis / Vigilis-Research, version "béton") :
 *
 *  1. Score brut via [MessageScamDetector] :
 *     - modèle ML (embedding texte, n-grams, etc.)
 *     - règles (pattern de lien, OTP, "urgent", "account locked", etc.)
 *
 *  2. Enrichissement par threat-intel "directe" :
 *     - extraction des URLs du contenu et lookup via [ThreatIntelRepository.isKnownScamUrl]
 *     - ajout de REASON_URL_KNOWN_SCAM si au moins une URL est connue scam
 *
 *  3. Ajustement via [ThreatIntelRepository.adjustMessageResult] :
 *     - IOC externes, listes dynamiques, signaux back-end
 *
 *  4. Escalades déterministes :
 *     - sender / URL marqués scam
 *     - signaux de contenu forts (suspicious link pattern, anomalies de contenu)
 *     - signaux QR code (attackVectors + reasons) :
 *         * QR générique → bump de risque modéré
 *         * QR + sémantique paiement → escalade agressive
 *
 *  5. Journalisation structurée via [DetectionLogRepository] :
 *     - pour traçabilité, audit, et future feedback loop (DetectionFeedback).
 */
class AnalyzeIncomingMessageUseCase(
    private val messageScamDetector: MessageScamDetector,
    private val threatIntelRepository: ThreatIntelRepository,
    private val detectionLogRepository: DetectionLogRepository,
) {

    /**
     * Point d’entrée principal.
     */
    operator fun invoke(message: Message): DetectionResult {
        // 1) Score brut (ML + règles locales)
        val baseResult = messageScamDetector.analyze(message)

        // 2) Enrichissement threat-intel via scan direct des URLs du contenu
        val withUrlIntel = enrichWithUrlThreatIntel(message, baseResult)

        // 3) Ajustement additionnel par threat-intel (IOC externes, listes dynamiques, etc.)
        val intelAdjusted =
            threatIntelRepository.adjustMessageResult(
                message = message,
                initialResult = withUrlIntel,
            )

        // 4.a) Escalade pour sender/URL connus scam
        val afterScamIndicators = escalateForKnownScamIndicators(intelAdjusted)

        // 4.b) Escalade pour signaux de contenu (lien suspect, anomalie)
        val afterContentSignals = escalateForContentSignals(afterScamIndicators)

        // 4.c) Escalade QR code (générique vs orienté paiement)
        val afterQrSignals =
            escalateForQrSignals(
                message = message,
                currentResult = afterContentSignals,
            )

        // 5) Journalisation
        detectionLogRepository.logMessageDetection(
            message = message,
            result = afterQrSignals,
        )

        return afterQrSignals
    }

    // ---------------------------------------------------------------------
    // 2) Enrichissement threat-intel direct via URLs extraites du contenu
    // ---------------------------------------------------------------------

    /**
     * Scanne le contenu textuel pour extraire les URLs "http(s)://...".
     * Pour chaque URL, interroge [ThreatIntelRepository.isKnownScamUrl].
     *
     * Si au moins une URL est connue scam, on ajoute REASON_URL_KNOWN_SCAM.
     */
    private fun enrichWithUrlThreatIntel(
        message: Message,
        currentResult: DetectionResult,
    ): DetectionResult {
        val content = message.content
        val urls =
            URL_REGEX
                .findAll(content)
                .map { it.value }
                .toSet()

        if (urls.isEmpty()) {
            return currentResult
        }

        var hasScamUrl = false
        for (url in urls) {
            if (threatIntelRepository.isKnownScamUrl(url)) {
                hasScamUrl = true
                break
            }
        }

        if (!hasScamUrl) {
            return currentResult
        }

        if (currentResult.reasons.contains(REASON_URL_KNOWN_SCAM)) {
            // Déjà marqué par un autre composant, inutile de dupliquer.
            return currentResult
        }

        return currentResult.copy(
            reasons = currentResult.reasons + REASON_URL_KNOWN_SCAM,
        )
    }

    // ---------------------------------------------------------------------
    // 4.a) Escalade pour sender / URL connus scam
    // ---------------------------------------------------------------------

    /**
     * Escalade si la threat-intel (directe ou ajustement) a marqué le sender
     * ou une URL comme scam.
     *
     * Contrat : reasons possibles en entrée :
     *  - [REASON_SENDER_KNOWN_SCAM]
     *  - [REASON_URL_KNOWN_SCAM]
     */
    private fun escalateForKnownScamIndicators(
        currentResult: DetectionResult,
    ): DetectionResult {
        val reasons = currentResult.reasons.toSet()

        val hasScamSender = reasons.contains(REASON_SENDER_KNOWN_SCAM)
        val hasScamUrl = reasons.contains(REASON_URL_KNOWN_SCAM)

        if (!hasScamSender && !hasScamUrl) {
            return currentResult
        }

        val hasBoth = hasScamSender && hasScamUrl

        val targetRisk =
            when {
                hasBoth ->
                    when (currentResult.riskLevel) {
                        RiskLevel.LOW,
                        RiskLevel.MEDIUM,
                        RiskLevel.HIGH,
                        -> RiskLevel.CRITICAL
                        RiskLevel.CRITICAL -> RiskLevel.CRITICAL
                    }

                else ->
                    when (currentResult.riskLevel) {
                        RiskLevel.LOW -> RiskLevel.HIGH
                        RiskLevel.MEDIUM -> RiskLevel.HIGH
                        RiskLevel.HIGH -> RiskLevel.HIGH
                        RiskLevel.CRITICAL -> RiskLevel.CRITICAL
                    }
            }

        val targetConfidence =
            if (hasBoth) {
                maxOf(currentResult.confidenceScore, 0.97)
            } else {
                maxOf(currentResult.confidenceScore, 0.92)
            }

        val extraReasons = mutableListOf<String>()
        if (hasScamSender) {
            extraReasons += REASON_ESCALATION_SENDER_SCAM
        }
        if (hasScamUrl) {
            extraReasons += REASON_ESCALATION_URL_SCAM
        }

        return currentResult.copy(
            riskLevel = targetRisk,
            confidenceScore = targetConfidence,
            reasons = currentResult.reasons + extraReasons,
        )
    }

    // ---------------------------------------------------------------------
    // 4.b) Escalade pour signaux de contenu (lien suspect, anomalies)
    // ---------------------------------------------------------------------

    /**
     * Escalade basée sur des signaux "contenu suspect" :
     *
     * Contrat : reasons possibles en entrée :
     *  - [REASON_SUSPICIOUS_LINK_PATTERN]
     *  - [REASON_MESSAGE_CONTENT_ANOMALY]
     */
    private fun escalateForContentSignals(
        currentResult: DetectionResult,
    ): DetectionResult {
        val reasons = currentResult.reasons.toSet()

        val hasSuspiciousLink = reasons.contains(REASON_SUSPICIOUS_LINK_PATTERN)
        val hasContentAnomaly = reasons.contains(REASON_MESSAGE_CONTENT_ANOMALY)

        val contentSignalsCount =
            listOf(hasSuspiciousLink, hasContentAnomaly)
                .count { it }

        if (contentSignalsCount == 0) {
            return currentResult
        }

        var escalatedRisk = bumpRisk(currentResult.riskLevel)
        var escalatedConfidence = maxOf(currentResult.confidenceScore, 0.85)

        if (contentSignalsCount >= 2) {
            escalatedRisk = bumpRisk(escalatedRisk)
            escalatedConfidence = maxOf(escalatedConfidence, 0.93)
        }

        val extraReasons = mutableListOf<String>()
        if (hasSuspiciousLink) {
            extraReasons += REASON_ESCALATION_SUSPICIOUS_LINK
        }
        if (hasContentAnomaly) {
            extraReasons += REASON_ESCALATION_CONTENT_ANOMALY
        }

        return currentResult.copy(
            riskLevel = escalatedRisk,
            confidenceScore = escalatedConfidence,
            reasons = currentResult.reasons + extraReasons,
        )
    }

    // ---------------------------------------------------------------------
    // 4.c) Escalade spécifique QR code (générique vs paiement)
    // ---------------------------------------------------------------------

    /**
     * Escalade basée sur les signaux QR :
     *
     *  - attackVectors contenant un vecteur dont le nom contient "qr"
     *  - reasons contenant "qr_code_*"
     *
     *  Heuristique :
     *   - QR code seul → bump modéré.
     *   - QR code + sémantique paiement détectée dans le contenu
     *     (ex. "scan to pay", "payer", "momo", "crypto", etc.) → escalade agressive.
     */
    private fun escalateForQrSignals(
        message: Message,
        currentResult: DetectionResult,
    ): DetectionResult {
        val reasons = currentResult.reasons.toSet()

        val hasQrReason =
            reasons.any { reason ->
                reason.contains("qr_code", ignoreCase = true)
            }

        val hasQrVector =
            currentResult.attackVectors
                .map { it.toString().lowercase() }
                .any { name ->
                    name.contains("qr")
                }

        if (!hasQrReason && !hasQrVector) {
            return currentResult
        }

        var risk = currentResult.riskLevel
        var confidence = currentResult.confidenceScore
        val extraReasons = mutableListOf<String>()

        // 1er niveau : QR code présent → on ne laisse pas en LOW silencieux.
        if (risk == RiskLevel.LOW) {
            risk = RiskLevel.MEDIUM
            confidence = maxOf(confidence, 0.88)
        } else {
            // bump léger pour les autres niveaux
            risk = bumpRisk(risk)
            confidence = maxOf(confidence, 0.90)
        }

        // 2e niveau : QR code clairement orienté paiement → escalade agressive.
        val hasPaymentSemantic = containsPaymentHint(message)
        if (hasPaymentSemantic) {
            risk =
                when (risk) {
                    RiskLevel.LOW,
                    RiskLevel.MEDIUM,
                    -> RiskLevel.HIGH
                    RiskLevel.HIGH -> RiskLevel.CRITICAL
                    RiskLevel.CRITICAL -> RiskLevel.CRITICAL
                }
            confidence = maxOf(confidence, 0.95)
            extraReasons += REASON_ESCALATION_QR_CODE_PAYMENT
        } else {
            extraReasons += REASON_ESCALATION_QR_CODE_GENERIC
        }

        return currentResult.copy(
            riskLevel = risk,
            confidenceScore = confidence,
            reasons = currentResult.reasons + extraReasons,
        )
    }

    /**
     * Heuristique simple pour détecter une sémantique "paiement"
     * dans le contenu du message.
     *
     * On reste volontairement large et orienté Afrique (MoMo, Orange Money, etc.).
     */
    private fun containsPaymentHint(message: Message): Boolean {
        val text = message.content.lowercase()

        val keywords =
            listOf(
                "paiement",
                "payer",
                "payment",
                "pay",
                "paye",
                "momo",
                "om",
                "orange money",
                "mobile money",
                "wave",
                "omoney",
                "wallet",
                "bitcoin",
                "btc",
                "crypto",
                "usdt",
                "scan to pay",
                "scan & pay",
                "transfert",
                "transfer",
                "virement",
                "envoyer de l'argent",
                "send money",
            )

        return keywords.any { keyword ->
            text.contains(keyword)
        }
    }

    // ---------------------------------------------------------------------
    // Helpers
    // ---------------------------------------------------------------------

    private fun bumpRisk(
        riskLevel: RiskLevel,
    ): RiskLevel =
        when (riskLevel) {
            RiskLevel.LOW -> RiskLevel.MEDIUM
            RiskLevel.MEDIUM -> RiskLevel.HIGH
            RiskLevel.HIGH -> RiskLevel.CRITICAL
            RiskLevel.CRITICAL -> RiskLevel.CRITICAL
        }

    companion object {
        // -----------------------------------------------------------------
        // Reasons attendus en entrée (moteur + threat-intel)
        // -----------------------------------------------------------------

        const val REASON_SENDER_KNOWN_SCAM = "sender_known_scam"
        const val REASON_URL_KNOWN_SCAM = "url_known_scam"
        const val REASON_SUSPICIOUS_LINK_PATTERN = "suspicious_link_pattern"
        const val REASON_MESSAGE_CONTENT_ANOMALY = "message_content_anomaly"

        // QR code marqués par le moteur / la threat-intel
        const val REASON_QR_CODE_PRESENT = "qr_code_present"
        const val REASON_QR_CODE_PAYMENT = "qr_code_payment"

        // -----------------------------------------------------------------
        // Reasons ajoutés par ce use-case (escalades déterministes)
        // -----------------------------------------------------------------

        private const val REASON_ESCALATION_SENDER_SCAM =
            "escalation_sender_known_scam"
        private const val REASON_ESCALATION_URL_SCAM =
            "escalation_url_known_scam"
        private const val REASON_ESCALATION_SUSPICIOUS_LINK =
            "escalation_suspicious_link"
        private const val REASON_ESCALATION_CONTENT_ANOMALY =
            "escalation_message_content_anomaly"

        private const val REASON_ESCALATION_QR_CODE_GENERIC =
            "escalation_qr_code_generic"
        private const val REASON_ESCALATION_QR_CODE_PAYMENT =
            "escalation_qr_code_payment"

        // Regex simple pour extraire les URLs http/https du contenu.
        private val URL_REGEX =
            "(https?://[\\S]+)".toRegex(RegexOption.IGNORE_CASE)
    }
}
